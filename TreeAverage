(defn sum-tree [tree]
  (cond
    (number? tree)  tree                               ;Check if pulled value is a number, then passes the tree again
    (empty?  tree)  0
    :else
    (+ (sum-tree (first tree)) (sum-tree (rest tree))) ;Otherwise add the first to the tree to the last of the tree
    ))

(defn count-tree [tree]
  (cond
    (nil? tree) 0
    (not (coll? tree)) 1                                     ;returns true if x implements a persistent collection eg (coll '()) = true but (coll 4) = false
                                                             ;Checks that its not one of them, so it means its a number. It will then add 1
    (empty? tree) 0                                          ;If the pulled element is empty add 0
    :else
    (+ (count-tree (first tree)) (count-tree (rest tree))))) ;Add the first node of tree, (current branch)
                                                             ;Recur through the rest of the tree

(defn count-tree-recur [tree]
  (cond
    (nil? tree) 0
    (not (coll? tree)) 1   ;returns true if x implements a persistent collection eg (coll '()) = true but (coll 4) = false
                           ;Checks that its not one of them, so it means its a number. It will then add 1
    (empty? tree) 0        ;If the pulled element is empty add 0
    :else
    (+ (count-tree-recur (first tree)) (count-tree-recur (rest tree))))) ;Add the first node of tree, (current branch)
                                                                         ;Recur through the rest of the tree

(defn nested-average-denest-v2 [tree]                   ;define function takes sequence as argument
  (/ (reduce + (flatten tree))(count (flatten tree))))  ;divide the total of the flattened tree by the number of elements in the flattened tree

;Create helper function to check against all the values

;(defn tree-average [tree]
;  (cond
;    (number? tree) tree
;    (nil? tree) 0
;    ;(not (coll? tree)) 1
;    (empty? tree) 0
;    :else
;    (/ )
;    ))

(defn pleb-tree-average [tree]
  (cond
    (number? tree) tree
    (nil? tree) 0
    ; not (coll? tree)) 1
    (empty? tree) 0)
    :else
    ( (fn(+ (pleb-tree-average (first tree)) (pleb-tree-average (rest tree))))

    ))

(defn method-tree-average [tree]
  (/ (sum-tree [tree]) (count-tree [tree])))  ;Uses the already created methods to find the average