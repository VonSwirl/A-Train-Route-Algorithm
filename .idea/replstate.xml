<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1491222563424">{:repl-history {:ide [], :local [&quot;Loading src/Uva301.clj... done&quot; &quot;(defn is-order-within-size [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 17. true is returned if it is within the limit\n    else false\&quot;\n  (&lt; (count map-we-give) 18))&quot; &quot;(is-order-within-size[orders-too-large])&quot; &quot;(ns Uva301)\n\n(declare breadth-search-)\n\n;-----------------------------------------------------------------------------------------------------\n\n(defn breadth-search\n  [start goal lmg &amp; {:keys [debug compare]\n                     :or   {debug   false\n                            compare =}}]\n  (let [goal? (if (fn? goal)\n                #(when (goal %) %)\n                #(when (= % goal) %))\n        ]\n    ;; a daft check but required just in case\n    (or (goal? start)\n        (breadth-search- `((~start)) goal? lmg compare debug)\n        )))\n\n\n(defn breadth-search- [waiting goal? lmg compare debug]\n  (let [member? (fn [lis x] (some (partial compare x) lis))\n        visited #{}\n        ]\n    (when debug (println 'waiting= waiting 'visited= visited))\n    (loop [waiting waiting\n           visited visited\n           ]\n      (if (empty? waiting) nil\n                           (let [[next &amp; waiting] waiting\n                                 [state &amp; path] next\n                                 visited? (partial member? visited)\n                                 ]\n                             (if (visited? state)\n                               (recur waiting visited)\n                               (let [succs (remove visited? (lmg state))\n                                     g (some goal? succs)\n                                     ]\n                                 (if g (reverse (cons g next))\n                                       (recur (concat waiting (map #(cons % next) succs))\n                                              (cons state visited)))\n                                 )))))))\n\n;-----------------------------------------------------------------------------------------------------\n\n;Makes an order\n(defn make-order [start end passengers]\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n(defn is-order-within-size [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 17. true is returned if it is within the limit\n    else false\&quot;\n  (&lt; (count map-we-give) 18))\n\n;Helper to validate make-order. Returns TRUE if the data argument is compatable with the uva301 problem\n(defn is-valid [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n  if it contains 0 orders/values false is returned else true\&quot;\n  (every? empty? [map-we-give])is-order-within-size [map-we-give])\n\n;Values used to create orders\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n(def orders-too-large\n  \&quot;Creates mock orders that is over the size limit\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n\n;Function used to create all possible states\n(defn make-state [current-station max-capacity end-station]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard. To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n;newer\n;\n(def start-state (make-state 1 10 4))\n\n\n;-----------------------------------------------------------------------------------------------------\n\n;let people off the bus - so filter people due to come off this station\n;reduce current capacity\n;go to next station\n;see if this guy can come on\n;if he can add him on to current-pass\n;add to current capacity\n;update value\n;finish move fn - work out how to make into hash maps objects\n\n(defn move [current-state new-order]\n  \&quot;Has one state, can passenger get on?, can passenger get off? are we outside of bounds? sends states to map \&quot;\n  (do\n    (update current-state :station inc)\n    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n    (update current-state :current-passengers new-order)\n    ()\n\n    current-state ()\n    ))\n\n;(defn move\n;  \&quot;Update after each station firstly incrementing the station mumber,\n; checking of any passengers get off\\nthen on and finally going to the new order\&quot;\n;  [current-state new-order end-station]\n;\n;  (do\n;    (update current-state :station inc)\n;    (update current-state :current-capacity (- (get current-state :curent-capacity) (get end-station :pass)))\n;    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n;    (update current-state :current-passengers new-order) ()\n;    current-state ()\n;    ))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;need to have a scenario where pasng get off but no new passng board to allow function to continue processing.\n;;\n;;\n;; # == anonyamous function\n;; set == #{}\n;; % == e.g (move state %) is (move state order)\n;lmg currently only takes one state needs to deal with all states\n;need a for-loop or something that iterates through all the states that are passed in.  do first\n;applying move to all orders and need to be able to capture the possibility that no orders are made at that station\n;add an end state - if current station is = to final-station that pass back all the states as a list\n;after lmg need mapped across all states retrieving the max value.\n\n(defn lmg [state order]\n  \&quot;has a list of states\&quot;\n  (recur (map #(move state %) (filter #(= (get % :start) (get state :station)) order)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;just to demo that it works\n;filter:- takes a predicate (if true keep)\n\n(defn i-filter-stuff [state order]\n  (filter #(= (get % :start) (get state :station)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;Not sure if these uncommented def's below are needed at the moment....work in progress monday 3rd jay\n\n;(def test-order (make-order 2 3 10))\n\n;(defn current-check [state order]\n;  \&quot;Needs to recursively stage through the stations and implement the lmg and move function for update\&quot;\n;  (recur (map #(move state %) order)))\n\n;base-case to be used for testing\n;(defn test-start-state [state] (state 0 10))\n\n;(defn solution [start end capacity ] (let [initial-state (state start capacity)])\n\n;-------END------------\n\n;==================================HISTORIC EFFORT===============================================================\n;(def orders-map\n;  \&quot;Defines a map of orders\&quot;\n;  '{:station0 {:order0 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;               :order1 {:seats 10 :start 0 :stop 3 :passengers 5 :order-num 2}\n;               }\n;    :station1 {:order0 {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;               :order1 {:seats 10 :start 1 :stop 3 :passengers 10 :order-num 4}\n;               }\n;    :station2 {:order0 {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;               ;:order1  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;               }\n;    :station3 {:order0 {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;               :order1 {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;               }\n;    :station4 {:order0 {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;               :order1 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;               }})\n;\n;(defn cap-check [orders current-capacity max-capacity])\n;(if (curent-capacity? == max-capacity)\n;  (false)\n;  (recur (inc orders ))\n;  )\n\n(def i-will-break-bysize\n  \&quot;Defines a map of orders\&quot;\n  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   :order11  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order12  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order13  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order44  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order35  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order66  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order27  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order78  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order79  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order110 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   })\n\n;................................START   JAYS    ADDITION...................\n;\n\n;\n;;TEST\n;;Copy block below to REPL to test lots-of-orders-map\n;(type orders-map)\n;(-&gt; orders-map :order1 :seats)\n;(-&gt; orders-map :order2 :start)\n;(-&gt; orders-map :order3 :stop)\n;(-&gt; orders-map :order4 :passengers)\n;(-&gt; orders-map :order5 :order-num)\n;;Test Successful\n;;--------------------------------------------------------------------------\n;\n;(def orders-hash-v1\n;  \&quot;Defines a hash-map of orders. Version 1\&quot;\n;  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n;   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n;   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;   })\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash v1\n;(type orders-hash-v1)\n;(-&gt; orders-hash-v1 :order1 :seats)\n;(-&gt; orders-hash-v1 :order2 :start)\n;(-&gt; orders-hash-v1 :order3 :stop)\n;(-&gt; orders-hash-v1 :order4 :passengers)\n;(-&gt; orders-hash-v1 :order5 :order-num)\n;;Test Successful\n;\n;\n(def i-will-break-im-empty\n  \&quot;Empty hashmap for test purposes\&quot;\n  ())\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash-empty\n;\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;\n;\n;\n;(def stations\n;  \&quot;defined stations and corresponding values\&quot;\n;  {\n;   :0-1 1 :0-2 2 :0-3 3 :0-4 4                            ;station 0 values\n;   :1-2 1 :1-3 2 :1-4 3                                   ;station 1 values\n;   :2-3 1 :2-4 2                                          ;station 2 values\n;   :3-4 1                                                 ;station 3 values\n;   })\n;\n;\n;(defn order-value [stations passengers]\n;  \&quot;Functions uses the above define stations to get the order value by\n;   (station stops * passenger count)\&quot;\n;  (* stations passengers))\n;\n;;TEST\n;;Copy block below to REPL to test order-value\n;(order-value (stations :1-4) 5)\n;(order-value (stations :0-3) 15)\n;(order-value (stations :2-4) 1)\n;;Test Successful\n;---------------------------------------------------------------------------\n\n;;TEST\n;;Copy block below to REPL to test order-empty\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v1) ;false\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v2) ;false\n;(is-order-empty orders-hash-empty) ;true\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;(defn is-order-within-size [map-we-give]\n;  \&quot;Helper function to validate that the given map/hashmap etc..\n;   does not exceed the maximum of 17. true is returned if it is within the limit\n;    else false\&quot;\n;  (&lt;= (count map-we-give) 17))\n;\n;;TEST\n;;Copy block below to REPL to test order-oversize\n;(is-order-within-size orders-hash-empty) ;true\n;(is-order-within-size orders-map) ;true\n;(is-order-within-size orders-hash-v1) ;true\n;(is-order-within-size orders-hash-v2)                     ;true\n;;Test Successful\n; (ns Practice)\n;(def english\n;  '{one 1, two 2, three 3, four 4})\n;\n;\n;(defn order [max-passengers end-station start-station num-orders num-passengers]\n;  (hash-map :max-pass max-passengers\n;            :end-stat end-station\n;            :start-stat start-station\n;            :num-ord num-orders\n;            :num-pass num-passengers\n;            :value (order-earnings end-station start-station num-passengers)\n;            ))\n;\n;;=&gt; #'user/order\n;(defn order-earnings [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;;=&gt; #'user/order-earnings\n;\n;\n;;(def order\n;;  {'(:max-passengers mp, :city-B-station bs, :num-orders 0)\n;;   '(:start-station s, :dest-station ds, :num-passengers np)})\n;;;=&gt; #'user/order\n\n;;(defn order-earnings [order]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1013)\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (dest-station, start-station)) num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/order-earnings (form-init2149713550713844186.clj:2)\n\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;=&gt; 60\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n\n\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;  (def testy (list (order 20 6 3 2 4) (order 20 6 2 1 1)) )\n;  ;=&gt; #'user/testy\n;  testy\n;   =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;  (map #(get % :value) testy)\n;  =&gt; (12 4)\n\n;(defn order [total-s new-p start-s end-s num-o]\n;  (hash-map :seats total-s\n;            :new-passengers new-p\n;            :start-station start-s\n;            :destination-station end-s\n;            :num-orders num-o\n;            :empty-seats (avail-seats total-s new-p)\n;            ))\n\n\n;(defn value [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;\n;;(defn avail-seats [total-s passng]\n;; (- total-s passng))\n;\n;(def person {:name \&quot;Steve\&quot; :age 24 :salary 7886 :company \&quot;Acme\&quot;})\n\n;(def creamchez {\&quot;seats\&quot; \&quot;total-s\&quot;\n;                :start-station start-s\n;                :destination-station end-s\n;                :passengers passng\n;                :num-orders num-or\n;                :value (value end-s start-s passng)})\n\n;(def order [total-s start-s end-s passng num-o]\n;  {:seats total-s\n;   :start-station start-s\n;   :destination-station end-s\n;   :passengers passng\n;   :num-orders num-or\n;   :value (value end-s start-s passng)})\n\n;(def stations {\&quot;0-1\&quot; 1\n;               :0-2  2\n;               :0-3  3\n;               :0-4  4\n;\n;               :1-2  1\n;               :1-3  2\n;               :1-4  3\n;\n;               :2-3  1\n;               :2-4  2\n;\n;               :3-4  1})\n\n;(order-value station :0-3 15)\n;\n;(defn order-value [stations passengers]\n;  ;get value from station which means its turned into its value\n;  ;then you can calculate upon it\n;\n;  (* stations passengers))\n\n\n;SOMEWHERE up here get all the orders and give them a numbers\n;(defn order-value [order station passengers]\n;get maximum order number\n;(*t passengers)\n;(decrement order and recur method)\n\n\n\n;\n;(def testValue\n;  t1(stations :0-1) :=&gt; 1)\n;  t2(stations :0-4) :=&gt; 4)\n;  t3(stations :2-4) :=&gt; 2))\n\n;(def city {\&quot;Seattle\&quot;  \&quot;cloudy\&quot;\n;           \&quot;Phoenix\&quot;  \&quot;sunny\&quot;\n;           \&quot;New York\&quot; \&quot;busy\&quot;})\n;\n;\n;(defn order [total-s start-s end-s passng num-o]\n;  (hash-map :seats total-s\n;            :start-station start-s\n;            :destination-station end-s\n;            :passengers passng\n;            :num-orders num-o\n;            ;:empty-seats (avail-seats total-s passng)\n;            :value (order-value stations passng)\n;            ))\n\n;(def english {one 1, two 2, three 3, four 4})\n;; using a map as a fn2\n;; user=&gt; ('two english); using a symbol as a fn2\n\n\n;(def testy (list (order 10 0 2 1 0)\n;                 (order 10 1 3 5 0)\n;                 (order 10 1 2 7 0)\n;                 (order 10 2 3 10 0)\n;                 (order 10 3 4 2 0)\n;                 (order 10 2 6 12 0)\n;                 (order 10 3 5 10 0)\n;                 (order 10 1 5 2 0)\n;                 (order 10 4 5 4 0)\n;                 (order 10 2 3 3 0)\n;                 ))\n\n;(select-keys {order} [:value :passengers])\n;(defn get\n;  (select-keys % {:value :passengers} [order]))\n\n\n;(map #(get % :value :passengers testy)\n\n\n;(defn avail-seats [total-s new-p]\n; (- total-s new-p))\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n;  (defn order-earnings [dest-station start-station num-passengers]\n;    (* (- dest-station start-station) num-passengers))\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;; breadth first search mechanism\n;; @args start start state\n;; @args goal either a predicate to take a state determine if it is a goal\n;;            or a state equal to the goal\n;; @args LMG  legal move generator function which takes one state &amp; returns\n;;            a list of states\n;; @args compare is a function which compares 2 states for equality,\n;;            = is used by default\n;; @arg debug prints some information\n\n&quot; &quot;(is-order-within-size[orders])&quot; &quot;(is-order-within-size[i-will-break-bysize])&quot; &quot;(ns Uva301)\n\n(declare breadth-search-)\n\n;-----------------------------------------------------------------------------------------------------\n\n(defn breadth-search\n  [start goal lmg &amp; {:keys [debug compare]\n                     :or   {debug   false\n                            compare =}}]\n  (let [goal? (if (fn? goal)\n                #(when (goal %) %)\n                #(when (= % goal) %))\n        ]\n    ;; a daft check but required just in case\n    (or (goal? start)\n        (breadth-search- `((~start)) goal? lmg compare debug)\n        )))\n\n\n(defn breadth-search- [waiting goal? lmg compare debug]\n  (let [member? (fn [lis x] (some (partial compare x) lis))\n        visited #{}\n        ]\n    (when debug (println 'waiting= waiting 'visited= visited))\n    (loop [waiting waiting\n           visited visited\n           ]\n      (if (empty? waiting) nil\n                           (let [[next &amp; waiting] waiting\n                                 [state &amp; path] next\n                                 visited? (partial member? visited)\n                                 ]\n                             (if (visited? state)\n                               (recur waiting visited)\n                               (let [succs (remove visited? (lmg state))\n                                     g (some goal? succs)\n                                     ]\n                                 (if g (reverse (cons g next))\n                                       (recur (concat waiting (map #(cons % next) succs))\n                                              (cons state visited)))\n                                 )))))))\n\n;-----------------------------------------------------------------------------------------------------\n\n;Makes an order\n(defn make-order [start end passengers]\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n(defn is-order-within-size [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 17. true is returned if it is within the limit\n    else false\&quot;\n  (&gt; (count map-we-give) 18))\n\n;Helper to validate make-order. Returns TRUE if the data argument is compatable with the uva301 problem\n(defn is-valid [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n  if it contains 0 orders/values false is returned else true\&quot;\n  (every? empty? [map-we-give])is-order-within-size [map-we-give])\n\n;Values used to create orders\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n(def orders-too-large\n  \&quot;Creates mock orders that is over the size limit\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n\n;Function used to create all possible states\n(defn make-state [current-station max-capacity end-station]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard. To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n;newer\n;\n(def start-state (make-state 1 10 4))\n\n\n;-----------------------------------------------------------------------------------------------------\n\n;let people off the bus - so filter people due to come off this station\n;reduce current capacity\n;go to next station\n;see if this guy can come on\n;if he can add him on to current-pass\n;add to current capacity\n;update value\n;finish move fn - work out how to make into hash maps objects\n\n(defn move [current-state new-order]\n  \&quot;Has one state, can passenger get on?, can passenger get off? are we outside of bounds? sends states to map \&quot;\n  (do\n    (update current-state :station inc)\n    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n    (update current-state :current-passengers new-order)\n    ()\n\n    current-state ()\n    ))\n\n;(defn move\n;  \&quot;Update after each station firstly incrementing the station mumber,\n; checking of any passengers get off\\nthen on and finally going to the new order\&quot;\n;  [current-state new-order end-station]\n;\n;  (do\n;    (update current-state :station inc)\n;    (update current-state :current-capacity (- (get current-state :curent-capacity) (get end-station :pass)))\n;    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n;    (update current-state :current-passengers new-order) ()\n;    current-state ()\n;    ))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;need to have a scenario where pasng get off but no new passng board to allow function to continue processing.\n;;\n;;\n;; # == anonyamous function\n;; set == #{}\n;; % == e.g (move state %) is (move state order)\n;lmg currently only takes one state needs to deal with all states\n;need a for-loop or something that iterates through all the states that are passed in.  do first\n;applying move to all orders and need to be able to capture the possibility that no orders are made at that station\n;add an end state - if current station is = to final-station that pass back all the states as a list\n;after lmg need mapped across all states retrieving the max value.\n\n(defn lmg [state order]\n  \&quot;has a list of states\&quot;\n  (recur (map #(move state %) (filter #(= (get % :start) (get state :station)) order)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;just to demo that it works\n;filter:- takes a predicate (if true keep)\n\n(defn i-filter-stuff [state order]\n  (filter #(= (get % :start) (get state :station)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;Not sure if these uncommented def's below are needed at the moment....work in progress monday 3rd jay\n\n;(def test-order (make-order 2 3 10))\n\n;(defn current-check [state order]\n;  \&quot;Needs to recursively stage through the stations and implement the lmg and move function for update\&quot;\n;  (recur (map #(move state %) order)))\n\n;base-case to be used for testing\n;(defn test-start-state [state] (state 0 10))\n\n;(defn solution [start end capacity ] (let [initial-state (state start capacity)])\n\n;-------END------------\n\n;==================================HISTORIC EFFORT===============================================================\n;(def orders-map\n;  \&quot;Defines a map of orders\&quot;\n;  '{:station0 {:order0 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;               :order1 {:seats 10 :start 0 :stop 3 :passengers 5 :order-num 2}\n;               }\n;    :station1 {:order0 {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;               :order1 {:seats 10 :start 1 :stop 3 :passengers 10 :order-num 4}\n;               }\n;    :station2 {:order0 {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;               ;:order1  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;               }\n;    :station3 {:order0 {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;               :order1 {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;               }\n;    :station4 {:order0 {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;               :order1 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;               }})\n;\n;(defn cap-check [orders current-capacity max-capacity])\n;(if (curent-capacity? == max-capacity)\n;  (false)\n;  (recur (inc orders ))\n;  )\n\n(def i-will-break-bysize\n  \&quot;Defines a map of orders\&quot;\n  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   :order11  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order12  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order13  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order44  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order35  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order66  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order27  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order78  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order79  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order110 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   })\n\n;................................START   JAYS    ADDITION...................\n;\n\n;\n;;TEST\n;;Copy block below to REPL to test lots-of-orders-map\n;(type orders-map)\n;(-&gt; orders-map :order1 :seats)\n;(-&gt; orders-map :order2 :start)\n;(-&gt; orders-map :order3 :stop)\n;(-&gt; orders-map :order4 :passengers)\n;(-&gt; orders-map :order5 :order-num)\n;;Test Successful\n;;--------------------------------------------------------------------------\n;\n;(def orders-hash-v1\n;  \&quot;Defines a hash-map of orders. Version 1\&quot;\n;  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n;   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n;   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;   })\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash v1\n;(type orders-hash-v1)\n;(-&gt; orders-hash-v1 :order1 :seats)\n;(-&gt; orders-hash-v1 :order2 :start)\n;(-&gt; orders-hash-v1 :order3 :stop)\n;(-&gt; orders-hash-v1 :order4 :passengers)\n;(-&gt; orders-hash-v1 :order5 :order-num)\n;;Test Successful\n;\n;\n(def i-will-break-im-empty\n  \&quot;Empty hashmap for test purposes\&quot;\n  ())\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash-empty\n;\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;\n;\n;\n;(def stations\n;  \&quot;defined stations and corresponding values\&quot;\n;  {\n;   :0-1 1 :0-2 2 :0-3 3 :0-4 4                            ;station 0 values\n;   :1-2 1 :1-3 2 :1-4 3                                   ;station 1 values\n;   :2-3 1 :2-4 2                                          ;station 2 values\n;   :3-4 1                                                 ;station 3 values\n;   })\n;\n;\n;(defn order-value [stations passengers]\n;  \&quot;Functions uses the above define stations to get the order value by\n;   (station stops * passenger count)\&quot;\n;  (* stations passengers))\n;\n;;TEST\n;;Copy block below to REPL to test order-value\n;(order-value (stations :1-4) 5)\n;(order-value (stations :0-3) 15)\n;(order-value (stations :2-4) 1)\n;;Test Successful\n;---------------------------------------------------------------------------\n\n;;TEST\n;;Copy block below to REPL to test order-empty\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v1) ;false\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v2) ;false\n;(is-order-empty orders-hash-empty) ;true\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;(defn is-order-within-size [map-we-give]\n;  \&quot;Helper function to validate that the given map/hashmap etc..\n;   does not exceed the maximum of 17. true is returned if it is within the limit\n;    else false\&quot;\n;  (&lt;= (count map-we-give) 17))\n;\n;;TEST\n;;Copy block below to REPL to test order-oversize\n;(is-order-within-size orders-hash-empty) ;true\n;(is-order-within-size orders-map) ;true\n;(is-order-within-size orders-hash-v1) ;true\n;(is-order-within-size orders-hash-v2)                     ;true\n;;Test Successful\n; (ns Practice)\n;(def english\n;  '{one 1, two 2, three 3, four 4})\n;\n;\n;(defn order [max-passengers end-station start-station num-orders num-passengers]\n;  (hash-map :max-pass max-passengers\n;            :end-stat end-station\n;            :start-stat start-station\n;            :num-ord num-orders\n;            :num-pass num-passengers\n;            :value (order-earnings end-station start-station num-passengers)\n;            ))\n;\n;;=&gt; #'user/order\n;(defn order-earnings [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;;=&gt; #'user/order-earnings\n;\n;\n;;(def order\n;;  {'(:max-passengers mp, :city-B-station bs, :num-orders 0)\n;;   '(:start-station s, :dest-station ds, :num-passengers np)})\n;;;=&gt; #'user/order\n\n;;(defn order-earnings [order]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1013)\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (dest-station, start-station)) num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/order-earnings (form-init2149713550713844186.clj:2)\n\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;=&gt; 60\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n\n\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;  (def testy (list (order 20 6 3 2 4) (order 20 6 2 1 1)) )\n;  ;=&gt; #'user/testy\n;  testy\n;   =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;  (map #(get % :value) testy)\n;  =&gt; (12 4)\n\n;(defn order [total-s new-p start-s end-s num-o]\n;  (hash-map :seats total-s\n;            :new-passengers new-p\n;            :start-station start-s\n;            :destination-station end-s\n;            :num-orders num-o\n;            :empty-seats (avail-seats total-s new-p)\n;            ))\n\n\n;(defn value [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;\n;;(defn avail-seats [total-s passng]\n;; (- total-s passng))\n;\n;(def person {:name \&quot;Steve\&quot; :age 24 :salary 7886 :company \&quot;Acme\&quot;})\n\n;(def creamchez {\&quot;seats\&quot; \&quot;total-s\&quot;\n;                :start-station start-s\n;                :destination-station end-s\n;                :passengers passng\n;                :num-orders num-or\n;                :value (value end-s start-s passng)})\n\n;(def order [total-s start-s end-s passng num-o]\n;  {:seats total-s\n;   :start-station start-s\n;   :destination-station end-s\n;   :passengers passng\n;   :num-orders num-or\n;   :value (value end-s start-s passng)})\n\n;(def stations {\&quot;0-1\&quot; 1\n;               :0-2  2\n;               :0-3  3\n;               :0-4  4\n;\n;               :1-2  1\n;               :1-3  2\n;               :1-4  3\n;\n;               :2-3  1\n;               :2-4  2\n;\n;               :3-4  1})\n\n;(order-value station :0-3 15)\n;\n;(defn order-value [stations passengers]\n;  ;get value from station which means its turned into its value\n;  ;then you can calculate upon it\n;\n;  (* stations passengers))\n\n\n;SOMEWHERE up here get all the orders and give them a numbers\n;(defn order-value [order station passengers]\n;get maximum order number\n;(*t passengers)\n;(decrement order and recur method)\n\n\n\n;\n;(def testValue\n;  t1(stations :0-1) :=&gt; 1)\n;  t2(stations :0-4) :=&gt; 4)\n;  t3(stations :2-4) :=&gt; 2))\n\n;(def city {\&quot;Seattle\&quot;  \&quot;cloudy\&quot;\n;           \&quot;Phoenix\&quot;  \&quot;sunny\&quot;\n;           \&quot;New York\&quot; \&quot;busy\&quot;})\n;\n;\n;(defn order [total-s start-s end-s passng num-o]\n;  (hash-map :seats total-s\n;            :start-station start-s\n;            :destination-station end-s\n;            :passengers passng\n;            :num-orders num-o\n;            ;:empty-seats (avail-seats total-s passng)\n;            :value (order-value stations passng)\n;            ))\n\n;(def english {one 1, two 2, three 3, four 4})\n;; using a map as a fn2\n;; user=&gt; ('two english); using a symbol as a fn2\n\n\n;(def testy (list (order 10 0 2 1 0)\n;                 (order 10 1 3 5 0)\n;                 (order 10 1 2 7 0)\n;                 (order 10 2 3 10 0)\n;                 (order 10 3 4 2 0)\n;                 (order 10 2 6 12 0)\n;                 (order 10 3 5 10 0)\n;                 (order 10 1 5 2 0)\n;                 (order 10 4 5 4 0)\n;                 (order 10 2 3 3 0)\n;                 ))\n\n;(select-keys {order} [:value :passengers])\n;(defn get\n;  (select-keys % {:value :passengers} [order]))\n\n\n;(map #(get % :value :passengers testy)\n\n\n;(defn avail-seats [total-s new-p]\n; (- total-s new-p))\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n;  (defn order-earnings [dest-station start-station num-passengers]\n;    (* (- dest-station start-station) num-passengers))\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;; breadth first search mechanism\n;; @args start start state\n;; @args goal either a predicate to take a state determine if it is a goal\n;;            or a state equal to the goal\n;; @args LMG  legal move generator function which takes one state &amp; returns\n;;            a list of states\n;; @args compare is a function which compares 2 states for equality,\n;;            = is used by default\n;; @arg debug prints some information\n\n&quot; &quot;(is-order-within-size [i-will-break-bysize])&quot; &quot;(is-order-within-size [orders])&quot; &quot;(is-order-within-size [0 9 8])&quot; &quot;(ns Uva301)\n\n(declare breadth-search-)\n\n;-----------------------------------------------------------------------------------------------------\n\n(defn breadth-search\n  [start goal lmg &amp; {:keys [debug compare]\n                     :or   {debug   false\n                            compare =}}]\n  (let [goal? (if (fn? goal)\n                #(when (goal %) %)\n                #(when (= % goal) %))\n        ]\n    ;; a daft check but required just in case\n    (or (goal? start)\n        (breadth-search- `((~start)) goal? lmg compare debug)\n        )))\n\n\n(defn breadth-search- [waiting goal? lmg compare debug]\n  (let [member? (fn [lis x] (some (partial compare x) lis))\n        visited #{}\n        ]\n    (when debug (println 'waiting= waiting 'visited= visited))\n    (loop [waiting waiting\n           visited visited\n           ]\n      (if (empty? waiting) nil\n                           (let [[next &amp; waiting] waiting\n                                 [state &amp; path] next\n                                 visited? (partial member? visited)\n                                 ]\n                             (if (visited? state)\n                               (recur waiting visited)\n                               (let [succs (remove visited? (lmg state))\n                                     g (some goal? succs)\n                                     ]\n                                 (if g (reverse (cons g next))\n                                       (recur (concat waiting (map #(cons % next) succs))\n                                              (cons state visited)))\n                                 )))))))\n\n;-----------------------------------------------------------------------------------------------------\n\n;Makes an order\n(defn make-order [start end passengers]\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n(defn is-order-within-size [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 17. true is returned if it is within the limit\n    else false\&quot;\n  (&gt; (count map-we-give) 5))\n\n;Helper to validate make-order. Returns TRUE if the data argument is compatable with the uva301 problem\n(defn is-valid [map-we-give]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n  if it contains 0 orders/values false is returned else true\&quot;\n  (every? empty? [map-we-give])is-order-within-size [map-we-give])\n\n;Values used to create orders\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n(def orders-too-large\n  \&quot;Creates mock orders that is over the size limit\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n\n;Function used to create all possible states\n(defn make-state [current-station max-capacity end-station]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard. To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n;newer\n;\n(def start-state (make-state 1 10 4))\n\n\n;-----------------------------------------------------------------------------------------------------\n\n;let people off the bus - so filter people due to come off this station\n;reduce current capacity\n;go to next station\n;see if this guy can come on\n;if he can add him on to current-pass\n;add to current capacity\n;update value\n;finish move fn - work out how to make into hash maps objects\n\n(defn move [current-state new-order]\n  \&quot;Has one state, can passenger get on?, can passenger get off? are we outside of bounds? sends states to map \&quot;\n  (do\n    (update current-state :station inc)\n    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n    (update current-state :current-passengers new-order)\n    ()\n\n    current-state ()\n    ))\n\n;(defn move\n;  \&quot;Update after each station firstly incrementing the station mumber,\n; checking of any passengers get off\\nthen on and finally going to the new order\&quot;\n;  [current-state new-order end-station]\n;\n;  (do\n;    (update current-state :station inc)\n;    (update current-state :current-capacity (- (get current-state :curent-capacity) (get end-station :pass)))\n;    (update current-state :current-capacity (+ (get current-state :current-capacity) (get new-order :pass)))\n;    (update current-state :current-passengers new-order) ()\n;    current-state ()\n;    ))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;need to have a scenario where pasng get off but no new passng board to allow function to continue processing.\n;;\n;;\n;; # == anonyamous function\n;; set == #{}\n;; % == e.g (move state %) is (move state order)\n;lmg currently only takes one state needs to deal with all states\n;need a for-loop or something that iterates through all the states that are passed in.  do first\n;applying move to all orders and need to be able to capture the possibility that no orders are made at that station\n;add an end state - if current station is = to final-station that pass back all the states as a list\n;after lmg need mapped across all states retrieving the max value.\n\n(defn lmg [state order]\n  \&quot;has a list of states\&quot;\n  (recur (map #(move state %) (filter #(= (get % :start) (get state :station)) order)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;just to demo that it works\n;filter:- takes a predicate (if true keep)\n\n(defn i-filter-stuff [state order]\n  (filter #(= (get % :start) (get state :station)) order))\n\n;----------------------------------------------------------------------------------------------------------------\n\n;Not sure if these uncommented def's below are needed at the moment....work in progress monday 3rd jay\n\n;(def test-order (make-order 2 3 10))\n\n;(defn current-check [state order]\n;  \&quot;Needs to recursively stage through the stations and implement the lmg and move function for update\&quot;\n;  (recur (map #(move state %) order)))\n\n;base-case to be used for testing\n;(defn test-start-state [state] (state 0 10))\n\n;(defn solution [start end capacity ] (let [initial-state (state start capacity)])\n\n;-------END------------\n\n;==================================HISTORIC EFFORT===============================================================\n;(def orders-map\n;  \&quot;Defines a map of orders\&quot;\n;  '{:station0 {:order0 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;               :order1 {:seats 10 :start 0 :stop 3 :passengers 5 :order-num 2}\n;               }\n;    :station1 {:order0 {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;               :order1 {:seats 10 :start 1 :stop 3 :passengers 10 :order-num 4}\n;               }\n;    :station2 {:order0 {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;               ;:order1  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;               }\n;    :station3 {:order0 {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;               :order1 {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;               }\n;    :station4 {:order0 {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;               :order1 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;               }})\n;\n;(defn cap-check [orders current-capacity max-capacity])\n;(if (curent-capacity? == max-capacity)\n;  (false)\n;  (recur (inc orders ))\n;  )\n\n(def i-will-break-bysize\n  \&quot;Defines a map of orders\&quot;\n  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   :order11  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n   :order12  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n   :order13  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n   :order44  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n   :order35  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n   :order66  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n   :order27  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n   :order78  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n   :order79  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n   :order110 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n   })\n\n;................................START   JAYS    ADDITION...................\n;\n\n;\n;;TEST\n;;Copy block below to REPL to test lots-of-orders-map\n;(type orders-map)\n;(-&gt; orders-map :order1 :seats)\n;(-&gt; orders-map :order2 :start)\n;(-&gt; orders-map :order3 :stop)\n;(-&gt; orders-map :order4 :passengers)\n;(-&gt; orders-map :order5 :order-num)\n;;Test Successful\n;;--------------------------------------------------------------------------\n;\n;(def orders-hash-v1\n;  \&quot;Defines a hash-map of orders. Version 1\&quot;\n;  {:order1  {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 1}\n;   :order2  {:seats 10 :start 1 :stop 3 :passengers 5 :order-num 2}\n;   :order3  {:seats 10 :start 1 :stop 2 :passengers 7 :order-num 3}\n;   :order4  {:seats 10 :start 2 :stop 3 :passengers 10 :order-num 4}\n;   :order5  {:seats 10 :start 3 :stop 4 :passengers 2 :order-num 5}\n;   :order6  {:seats 10 :start 2 :stop 6 :passengers 12 :order-num 6}\n;   :order7  {:seats 10 :start 3 :stop 5 :passengers 10 :order-num 7}\n;   :order8  {:seats 10 :start 1 :stop 5 :passengers 2 :order-num 8}\n;   :order9  {:seats 10 :start 4 :stop 5 :passengers 4 :order-num 9}\n;   :order10 {:seats 10 :start 0 :stop 1 :passengers 1 :order-num 10}\n;   })\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash v1\n;(type orders-hash-v1)\n;(-&gt; orders-hash-v1 :order1 :seats)\n;(-&gt; orders-hash-v1 :order2 :start)\n;(-&gt; orders-hash-v1 :order3 :stop)\n;(-&gt; orders-hash-v1 :order4 :passengers)\n;(-&gt; orders-hash-v1 :order5 :order-num)\n;;Test Successful\n;\n;\n(def i-will-break-im-empty\n  \&quot;Empty hashmap for test purposes\&quot;\n  ())\n;\n;;TEST\n;;Copy block below to REPL to test orders-hash-empty\n;\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;\n;\n;\n;(def stations\n;  \&quot;defined stations and corresponding values\&quot;\n;  {\n;   :0-1 1 :0-2 2 :0-3 3 :0-4 4                            ;station 0 values\n;   :1-2 1 :1-3 2 :1-4 3                                   ;station 1 values\n;   :2-3 1 :2-4 2                                          ;station 2 values\n;   :3-4 1                                                 ;station 3 values\n;   })\n;\n;\n;(defn order-value [stations passengers]\n;  \&quot;Functions uses the above define stations to get the order value by\n;   (station stops * passenger count)\&quot;\n;  (* stations passengers))\n;\n;;TEST\n;;Copy block below to REPL to test order-value\n;(order-value (stations :1-4) 5)\n;(order-value (stations :0-3) 15)\n;(order-value (stations :2-4) 1)\n;;Test Successful\n;---------------------------------------------------------------------------\n\n;;TEST\n;;Copy block below to REPL to test order-empty\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v1) ;false\n;(is-order-empty orders-hash-empty) ;true\n;(is-order-empty orders-hash-v2) ;false\n;(is-order-empty orders-hash-empty) ;true\n;;Test Successful\n;---------------------------------------------------------------------------\n;\n;(defn is-order-within-size [map-we-give]\n;  \&quot;Helper function to validate that the given map/hashmap etc..\n;   does not exceed the maximum of 17. true is returned if it is within the limit\n;    else false\&quot;\n;  (&lt;= (count map-we-give) 17))\n;\n;;TEST\n;;Copy block below to REPL to test order-oversize\n;(is-order-within-size orders-hash-empty) ;true\n;(is-order-within-size orders-map) ;true\n;(is-order-within-size orders-hash-v1) ;true\n;(is-order-within-size orders-hash-v2)                     ;true\n;;Test Successful\n; (ns Practice)\n;(def english\n;  '{one 1, two 2, three 3, four 4})\n;\n;\n;(defn order [max-passengers end-station start-station num-orders num-passengers]\n;  (hash-map :max-pass max-passengers\n;            :end-stat end-station\n;            :start-stat start-station\n;            :num-ord num-orders\n;            :num-pass num-passengers\n;            :value (order-earnings end-station start-station num-passengers)\n;            ))\n;\n;;=&gt; #'user/order\n;(defn order-earnings [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;;=&gt; #'user/order-earnings\n;\n;\n;;(def order\n;;  {'(:max-passengers mp, :city-B-station bs, :num-orders 0)\n;;   '(:start-station s, :dest-station ds, :num-passengers np)})\n;;;=&gt; #'user/order\n\n;;(defn order-earnings [order]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (:dest-station, :start-station)):num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1013)\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- (dest-station, start-station)) num-passengers))\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/order-earnings (form-init2149713550713844186.clj:2)\n\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n;;=&gt; 60\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n\n\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;  (def testy (list (order 20 6 3 2 4) (order 20 6 2 1 1)) )\n;  ;=&gt; #'user/testy\n;  testy\n;   =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;  (map #(get % :value) testy)\n;  =&gt; (12 4)\n\n;(defn order [total-s new-p start-s end-s num-o]\n;  (hash-map :seats total-s\n;            :new-passengers new-p\n;            :start-station start-s\n;            :destination-station end-s\n;            :num-orders num-o\n;            :empty-seats (avail-seats total-s new-p)\n;            ))\n\n\n;(defn value [dest-station start-station num-passengers]\n;  (* (- dest-station start-station) num-passengers))\n;\n;;(defn avail-seats [total-s passng]\n;; (- total-s passng))\n;\n;(def person {:name \&quot;Steve\&quot; :age 24 :salary 7886 :company \&quot;Acme\&quot;})\n\n;(def creamchez {\&quot;seats\&quot; \&quot;total-s\&quot;\n;                :start-station start-s\n;                :destination-station end-s\n;                :passengers passng\n;                :num-orders num-or\n;                :value (value end-s start-s passng)})\n\n;(def order [total-s start-s end-s passng num-o]\n;  {:seats total-s\n;   :start-station start-s\n;   :destination-station end-s\n;   :passengers passng\n;   :num-orders num-or\n;   :value (value end-s start-s passng)})\n\n;(def stations {\&quot;0-1\&quot; 1\n;               :0-2  2\n;               :0-3  3\n;               :0-4  4\n;\n;               :1-2  1\n;               :1-3  2\n;               :1-4  3\n;\n;               :2-3  1\n;               :2-4  2\n;\n;               :3-4  1})\n\n;(order-value station :0-3 15)\n;\n;(defn order-value [stations passengers]\n;  ;get value from station which means its turned into its value\n;  ;then you can calculate upon it\n;\n;  (* stations passengers))\n\n\n;SOMEWHERE up here get all the orders and give them a numbers\n;(defn order-value [order station passengers]\n;get maximum order number\n;(*t passengers)\n;(decrement order and recur method)\n\n\n\n;\n;(def testValue\n;  t1(stations :0-1) :=&gt; 1)\n;  t2(stations :0-4) :=&gt; 4)\n;  t3(stations :2-4) :=&gt; 2))\n\n;(def city {\&quot;Seattle\&quot;  \&quot;cloudy\&quot;\n;           \&quot;Phoenix\&quot;  \&quot;sunny\&quot;\n;           \&quot;New York\&quot; \&quot;busy\&quot;})\n;\n;\n;(defn order [total-s start-s end-s passng num-o]\n;  (hash-map :seats total-s\n;            :start-station start-s\n;            :destination-station end-s\n;            :passengers passng\n;            :num-orders num-o\n;            ;:empty-seats (avail-seats total-s passng)\n;            :value (order-value stations passng)\n;            ))\n\n;(def english {one 1, two 2, three 3, four 4})\n;; using a map as a fn2\n;; user=&gt; ('two english); using a symbol as a fn2\n\n\n;(def testy (list (order 10 0 2 1 0)\n;                 (order 10 1 3 5 0)\n;                 (order 10 1 2 7 0)\n;                 (order 10 2 3 10 0)\n;                 (order 10 3 4 2 0)\n;                 (order 10 2 6 12 0)\n;                 (order 10 3 5 10 0)\n;                 (order 10 1 5 2 0)\n;                 (order 10 4 5 4 0)\n;                 (order 10 2 3 3 0)\n;                 ))\n\n;(select-keys {order} [:value :passengers])\n;(defn get\n;  (select-keys % {:value :passengers} [order]))\n\n\n;(map #(get % :value :passengers testy)\n\n\n;(defn avail-seats [total-s new-p]\n; (- total-s new-p))\n\n;;(defn order-earnings [dest-station start-station num-passengers]\n;;  (* (- dest-station start-station) num-passengers))\n\n;;;=&gt; #'user/order-earnings\n\n;;(order-earnings 6 0 10)\n\n;  (defn order [max-passengers end-station start-station num-orders num-passengers]\n;    (hash-map :max-pass max-passengers\n;              :end-stat end-station\n;              :start-stat start-station\n;              :num-ord num-orders\n;              :num-pass num-passengers\n;              :value (order-earnings end-station start-station num-passengers)\n;              ))\n;\n;  ;=&gt; #'user/order\n;  (defn order-earnings [dest-station start-station num-passengers]\n;    (* (- dest-station start-station) num-passengers))\n; ; =&gt; #'user/order\n; ; =&gt; #'user/order-earnings\n\n\n;  (order 20 6 3 2 4)\n; ; =&gt; {:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n\n;  (list (order 20 6 3 2 4) (order 20 6 2 1 1))\n; ; =&gt;\n;  ({:num-pass 4, :value 12, :end-stat 6, :start-stat 3, :max-pass 20, :num-ord 2}\n;    {:num-pass 1, :value 4, :end-stat 6, :start-stat 2, :max-pass 20, :num-ord 1})\n;\n;; breadth first search mechanism\n;; @args start start state\n;; @args goal either a predicate to take a state determine if it is a goal\n;;            or a state equal to the goal\n;; @args LMG  legal move generator function which takes one state &amp; returns\n;;            a list of states\n;; @args compare is a function which compares 2 states for equality,\n;;            = is used by default\n;; @arg debug prints some information\n\n&quot; &quot;(is-order-within-size[1])&quot; &quot;(is-order-within-size[1 1 1 1 1 1 1 1 1 1 1 1 1 ])&quot; &quot;(is-order-within-size[1 1 1 1 1 ])&quot; &quot;(is-order-within-size[1 1 1 1 1 1])&quot;], :remote []}}</component>
</project>