<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1490711542093">{:repl-history {:ide [], :local [&quot;\n; matcher\n;===============================\n; v(0.0l)\n\n(ns ^{:doc \&quot;A Symbolic Pattern Matcher\&quot;\n      :author \&quot;SCL\&quot;}\ncgsx.tools.matcher)\n\n\n\n;--------------------------------------\n; globals, etc\n;--------------------------------------\n\n; matcher var pseudo name-space\n\n(def mvars {}) ; for outer environment - shadowed by lexical mvars\n\n(def ^:private mns-nam 'mvars)\n\n\n;--------------------------------------\n; helpers for matches\n;--------------------------------------\n\n(def rep-?  ^:private (re-pattern #\&quot;\\A\\?(.+)\&quot;))    ; singletons\n(def rep-?? ^:private (re-pattern #\&quot;\\A\\?\\?(.+)\&quot;))\n\n(defn- has-?-prefix\n  ; checks if sym has \\? prefix (but not \\?? prefix)\n  [sym]\n  (and (re-find rep-? (str sym))\n       (not (re-find rep-?? (str sym)))))\n\n\n(defn- has-??-prefix\n  ; checks if sym has ?? prefix\n  [sym]\n  (re-find rep-?? (str sym)))\n\n\n(defn- strip-first\n  ; strips first \&quot;?\&quot; char from a symbol/str, returning a symbol\n  [sym]\n  (symbol ((re-find rep-? (str sym)) 1)))\n\n\n(defn- strip-first2\n  ; strips first \&quot;??\&quot; chars from a symbol/str, returning a symbol\n  [sym]\n  (symbol ((re-find rep-?? (str sym)) 1)))\n\n\n\n;--------------------------------------\n; fn: matches &amp; associated fns\n;--------------------------------------\n\n(declare matcher:matches-)\n\n(defn- apply-all-predicates\n  [x fns]\n  ;(println \&quot;apply-all-predicates x=\&quot; x \&quot; fns=\&quot; fns)\n  (if (empty? fns) x\n                   (if-let [y ((first fns) x)]\n                     (recur (if (= y true) x y) (rest fns))\n                     )))\n\n\n\n(defn- eval-fns\n  ; this takes a list of either/mix of...\n  ; (i) functions\n  ; (ii) textual forms describing functions\n  ; any textual forms are evaluated to fns\n  [fns]\n  (map #(if (fn? %) % (eval %)) fns))\n\n\n\n(defn- absorb\n  [vnam p d bind &amp; {:keys [predicates]}]\n  ; NB: p is the remaining part of pattern\n  ; vnam is the name of the absorbing var\n  ; predicates is a list of fns to run bindings through\n  ; predicates will normally be quoted hence the test &amp; mapping\n  (let [predicates (eval-fns predicates)]\n    (loop [vbind () ; the value bound to vnam\n           data d ; the remaining data\n           ]\n      ;(println \&quot;absorb vb=\&quot; vbind \&quot; p=\&quot; p \&quot; d=\&quot; d)\n      (if-let [new-vbind (apply-all-predicates vbind predicates)]\n        (let [res (matcher:matches- p data (assoc bind vnam new-vbind))]\n          ;(println \&quot;--absorb new-vb=\&quot; new-vbind \&quot; res=\&quot; res)\n          (cond res res\n                (empty? data) nil\n                :else (recur `(~@vbind ~(first data)) (rest data))\n                ))\n        ; if-let else\n        (if (empty? data) nil\n                          (recur `(~@vbind ~(first data)) (rest data))\n                          )\n        ))))\n\n\n\n(defn matcher:matches-\n  [p d bind]\n  ;(println \&quot;matcher:matches-: p=\&quot; p \&quot;, d=\&quot; d \&quot;, bind=\&quot; bind)\n  (cond\n\n    ;__ tree down to level of symbols ____________\n    (= p d) bind ; p = d      =&gt; bind\n    (= p '?_) bind ; p is wild  =&gt; bind\n\n    (has-?-prefix p) ; p isa ?var\n    (if-let [b (bind (strip-first p))] ; if ?var is bound\n      (and (= b d) bind) ;     check match\n      (assoc bind (strip-first p) d)) ; else bind it\n\n    ; first check for a pair of maps\n    (and (map? p) (map? d))\n    (recur (sort (seq p)) (sort (seq d)) bind)  ; line them up for matching\n\n    ; now check for other collections\n    (and (coll? p) (not (empty? p))) ; p is non-empty seq\n    (cond\n      ;__  (-&gt; ?var pred..) _____\n      (and (= (first p) '-&gt;) (has-?-prefix (second p)))\n      (let [[v &amp; preds] (rest p)  ; this will trip an error if the pattern\n            v (strip-first v)    ; is badly formed but i guess this is ok\n            ]\n        (if-let [r (apply-all-predicates d (eval-fns preds))]\n          (assoc bind v r))\n        )\n\n      ;__ tree one level up _________________________\n\n      ;__  (-&gt; ??var pred..)... _____\n      (and (coll? (first p)) (= (ffirst p) '-&gt;)\n           (has-??-prefix (second (first p))))\n      (let [[_ v &amp; preds] (first p)    ; error on badly formed pattern\n            v  (strip-first2 v)\n            ]\n        (absorb v (rest p)\n                d bind :predicates preds))\n\n\n      ;__  ??_  ________\n      (= (first p) '??_)\n      (absorb (gensym 'tmp) (rest p) d bind)\n\n      ;__  ??var  ______\n      (has-??-prefix (first p))\n      (absorb (strip-first2 (first p)) (rest p) d bind)\n\n      ;__  data is a list ____\n      (and (coll? d) (not (empty? d))) ; d is non-empty seq\n      (if-let [b (matcher:matches- (first p) (first d) bind)]\n        (recur (rest p) (rest d) b) ; match first &amp; rest\n        nil)\n\n      :else nil\n      )\n\n    :else nil\n    ))\n\n\n\n\n(defmacro matches\n  ([p d] `(matcher:matches- ~p ~d (merge ~mns-nam {:pat ~p :it ~d})))\n  ([p d bind] `(matcher:matches- ~p ~d (merge ~mns-nam {:pat ~p :it ~d} ~bind)))\n  )\n\n\n\n\n;--------------------------------------\n; match out, mout\n;--------------------------------------\n\n\n(defn matcher:mout-\n  ; fill a pattern from mvars\n  [x mvars]\n  ;(println \&quot;** x=\&quot; x \&quot;, mvars=\&quot; mvars)\n\n  (if (coll? x)                  ;__ collections ___________________________\n    (cond\n      (empty? x)  x              ; so nils are not transformed to ()\n      ; &amp; vectors, etc have types preserved\n      (vector? x) (into [] (matcher:mout- (seq x) mvars))\n      (map? x)    (into {} (matcher:mout- (seq x) mvars))\n\n      ; other, including specials that must be handled at non-terminals...\n      (seq? x)\n      (let [[f &amp; r] x]\n        (cond\n          ; check ??var\n          (has-??-prefix f)\n          (let [f (or (mvars (strip-first2 f)) f)]\n            (if (seq? f)\n              (concat f (matcher:mout- r mvars))\n              (cons f (matcher:mout- r mvars))\n              ))\n\n          ; check :eval clause\n          (= f :eval)\n          ((eval `(fn [~mns-nam] ~@r)) mvars)\n\n          ; default list case\n          :else\n          (cons (matcher:mout- f mvars) (matcher:mout- r mvars))\n          )))\n\n    ;__ atomics _____________________________\n\n    (cond\n      ; check ?var\n      (has-?-prefix x)\n      (or (mvars (strip-first x)) x)\n\n      ; default case -- leave it unchanged\n      :else x\n      )))\n\n\n\n(defmacro mout [lis]\n  `(matcher:mout- ~lis ~mns-nam))\n\n\n\n;--------------------------------------\n; macros: ?, mlet, with-mvars\n;--------------------------------------\n\n;(def mns-nam 'mvars)\n\n(defmacro ?\n  ; lookup named variable in matcher name-space\n  [x]\n  `(~mns-nam '~x))\n\n\n(defmacro with-mvars\n  ; adds map of mvar names &amp; values to mvars then\n  ; evaluates the body in this context\n  [vmap &amp; body]\n  `(let [~mns-nam (merge ~mns-nam ~vmap)]\n     ~@body\n     ))\n\n\n\n;example...\n;\n;user=&gt; (with-mvars {'a (+ 2 3), 'b (- 3 4)}\n;         (println mvars)\n;         (with-mvars {'b 'bb, 'd 'xx, 'e 'yy}\n;           (println mvars)))\n;{b -1, a 5}\n;{e yy, d xx, b bb, a 5}\n\n\n(defmacro mlet\n  ; a matcher form of let\n  [[p d] &amp; body]\n  `(if-let [mbind# (matches ~p ~d)]\n     (let [~mns-nam mbind#]\n       ~@body)\n     ))\n\n\n\n;--------------------------------------\n; macros: mif\n;--------------------------------------\n\n(defmacro mif\n  ; a matcher form of if\n  ([[p d] then rest]\n   `(if-let [~mns-nam (matches ~p ~d)]\n      ~then ~rest))\n  ([[p d] then]\n   `(if-let [~mns-nam (matches ~p ~d)]\n      ~then))\n  )\n\n;--------------------------------------\n; macros: mcond\n;--------------------------------------\n\n\n(defmacro mcond\n  [[lis] &amp; forms]\n  (let [lis lis ;; eval only once\n        body (for [f forms]\n               `(mlet ['~(first f) ~lis] ~@(rest f))\n               )]\n    `(or ~@body)\n    ))\n\n\n; example...\n;\n;(defn calc [exp]\n;  (mcond [exp]\n;    ((?a minus ?b) :=&gt; (- (? a) (? b)))\n;    ((?a plus ?b)  :=&gt; (+ (? a) (? b)))\n;    ( ?_           :=&gt; 'unknown )\n;    ))\n\n\n\n;--------------------------------------\n; macros: mfind, mfind*\n;--------------------------------------\n\n\n(defmacro mfind\n  [[p data] &amp; body]\n  `(loop [d# (seq ~data)]\n     (if (empty? d#) nil\n                     (if-let [r# (mlet [~p (first d#)] ~@body)]\n                       r#\n                       (recur (rest d#))\n                       ))))\n\n\n; 150306\n; (if (empty? d#) d# =&gt; (if (empty? d#) nil\n;\n;(defmacro mfind\n;  [[p data] &amp; body]\n;  `(loop [d# (seq ~data)]\n;     (if (empty? d#) d#\n;       (if-let [r# (mlet [~p (first d#)] ~@body)]\n;         r#\n;         (recur (rest d#))\n;         ))))\n\n\n(defmacro mfind*\n  [[pats data] &amp; body]\n  (let [data data ;; eval only once\n        pats pats ;; ditto\n        ]\n    `(letfn [(f# [ps# ds# ~mns-nam]\n               ;(println mvars)\n               (cond\n                 (empty? ps#) ; all pats have matched\n                 (do ~@body)\n\n                 (empty? ds#) ; data exhausted\n                 nil\n\n                 (= :not (ffirst ps#))\n                 (let [x# (f# (rest (first ps#)) ~data ~mns-nam)]\n                   (if x# nil (f# (rest ps#) ~data ~mns-nam)))\n\n                 (= :guard (ffirst ps#))\n                 (let [foo# (eval `(fn [~'~mns-nam]\n                                     (and ~@(rest (first ps#)))))\n                       ]\n                   (and (foo# ~mns-nam)\n                        (f# (rest ps#) ~data ~mns-nam)))\n\n                 :else\n                 (or (mlet [(first ps#) (first ds#)]\n                           (f# (rest ps#) ~data ~mns-nam))\n                     (f# ps# (rest ds#) ~mns-nam)\n                     )\n                 ))\n             ]\n       (f# ~pats ~data ~mns-nam)\n       )))\n\n\n\n\n\n;--------------------------------------\n; macros: mfor, mfor*\n; fn:     matcher:strict-map\n;--------------------------------------\n\n\n(defn matcher:strict-map\n  ; like map but not lazy\n  [foo data]\n  (if (empty? data) data\n                    (cons (foo (first data)) (matcher:strict-map foo (rest data)))\n                    ))\n\n\n(defn matcher:safely-concat [data]\n  ; used in mfor* so its body can return symbolic forms\n  (remove #(= % nil)\n          (if (every? seq? data)\n            (reduce concat data)\n            data)))\n\n;(defn matcher:safely-concat [data]\n;  ; used in mfor* so its body can return symbolic forms\n;  (remove #(= % nil) data))\n;    (if (every? seq? data)\n;      (reduce concat data)\n;      data)))\n\n(defmacro mfor\n  [[p data] &amp; body]\n  `(remove #(= % nil)\n           (matcher:strict-map (fn [d#] (mlet [~p d#] ~@body)) ~data)))\n\n\n(defmacro mfor*\n  [[pats data] &amp; body]\n  (let [data data ;; eval only once\n        pats pats ;; ditto\n        ]\n    `(letfn [(f# [p# ~mns-nam]\n               (cond\n                 (empty? p#)\n                 (do (list ~@body))\n\n                 (= :not (ffirst p#))\n                 (let [x# (mfind* [(rest (first p#)) ~data] true)]\n                   (if x# nil (list (f# (rest p#) ~mns-nam))))\n\n                 (= :guard (ffirst p#))\n                 (let [foo# (eval `(fn [~'~mns-nam]\n                                     (and ~@(rest (first p#)))))\n                       x# (foo# ~mns-nam)\n                       ]\n                   (if x# (list (f# (rest p#) ~mns-nam))))\n\n                 :else\n                 (matcher:safely-concat\n                   (mfor [(first p#) ~data]\n                         (f# (rest p#) ~mns-nam))\n                   )\n                 ))]\n       (matcher:safely-concat (f# ~pats ~mns-nam))\n       )))\n\n\n\n;--------------------------------------\n; macros: defmatch mfn\n;--------------------------------------\n\n\n(defmacro defmatch\n  [name params &amp; forms]\n  (let [exp (gensym 'exp)\n        params (into [exp] params)\n        ]\n    `(defn ~name ~params\n       (mcond [~exp]\n              ~@forms)))\n  )\n\n\n;(defmatch blah []\n;  ((?a ?b ?c)  :=&gt; 'do-summin)\n;  ((whoops ?x) :=&gt; 'do-summin-else)\n;  )\n\n(defmacro mfn\n  [params &amp; forms]\n  (let [exp (gensym 'exp)\n        params (into [exp] params)\n        ]\n    `(fn ~params\n       (mcond [~exp]\n              ~@forms)))\n  )\n\n\n;--------------------------------------\n; macros: massert\n;--------------------------------------\n\n(defmacro massert\n  [[pat dat] text]\n  `(if-not (matches ~pat ~dat) (throw (RuntimeException. ~text))))\n\n\n\n\n\n;---- eof ----------------------------------------------------------------\n;-------------------------------------------------------------------------&quot; &quot;gfyfryyry&quot; &quot;;--------------TO-DO-----------------------------------------------------\n;more tests e.g nils, emptys, symbols, types.\n;run time tracing/ scalability\n;more funtions, matcher defmatch lenght, every seq, covert bitwise right?\n;reece formattin :)\n;review feedback for box ticking.\n;NEED helper funtion.\n;--------------TO-DO-----------------------------------------------------\n\n\n\n\n\n(defn nested-average-denest-v2 [tree]                   ;define function takes sequence as argument\n  (/ (reduce + (flatten tree))(count (flatten tree))))  ;divide the total of the flattened tree by the number of elements in the flattened tree\n;Test 1 - (nested-average-denestV2 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n;Expected = 18\n;Test 2 - (nested-average-denest-v2 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n;Expected = 15.375\n;-------------------------------------------------------\n(defn nested-average-denest-v1[tree]                    ;define function takes tree (nested list)\n  (let[denest (flatten tree)                            ;removes brackets and returns all elements in a single (flat)sequence\n       nest-count (count denest)                          ;counts all elements in sequence\n       sum-values (reduce + denest)]                    ;recursively sums all the values in sequence\n\n    (float (/ sum-values nest-count))\n    )\n  )\n;Test 1 - (nested-average-denest-v1 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n;Expected = 18\n;Test 2 - (nested-average-denest-v1 '(10 ((30 1) 20) (8 (5 ()) 9) 40))\n;Expected = 123/8(15.375)\n;-------------------------------------------------------\n&quot; &quot;(nested-average-denest-v1 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(nested-average-denestV2 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(nested-average-denest-v2 '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(splice-out1 2 3 '(a b c d e f))&quot; &quot;(addx [2 3] )&quot; &quot;(addx [3 5])&quot; &quot;(addx [3])&quot; &quot;()&quot; &quot;(addx '(3))&quot; &quot;(addx 3)&quot; &quot;(splice-out2 3 5 '(a b c d e f))&quot; &quot;fchcfh&quot; &quot;(+ 1 1)&quot; &quot;(method-tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(require '[clojure.tools.trace :refer :all])&quot; &quot;(trace-vars sum-tree '(10 ((30 1) 20) (8 (5 ()) 9) 40))&quot; &quot;(trace-vars sum-tree)&quot; &quot;(sum-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(trace-vars length-tree)&quot; &quot;(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 0))&quot; &quot;(compute-across [count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0])&quot; &quot;(compute-across [inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) \n                 ])&quot; &quot;(compute-across [inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0])&quot; &quot;(tail-count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0)&quot; &quot;(tail-count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))&quot; &quot;(tail-count inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0)&quot; &quot;(tail-count inc '(1) 0)&quot; &quot;Starting nREPL server...\n\&quot;C:\\Program Files\\Java\\jdk1.8.0_111\\bin\\java\&quot; -Didea.launcher.port=7532 \&quot;-Didea.launcher.bin.path=C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2016.3.4\\bin\&quot; -Dfile.encoding=UTF-8 -classpath \&quot;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\rt.jar;C:\\Users\\DeepThought2\\Documents\\WinSCP\\WINDOWS\\Modules\\A.I Programming\\IntelliJ Projects\\src;C:\\Users\\DeepThought2\\Documents\\WinSCP\\WINDOWS\\Modules\\A.I Programming\\IntelliJ Projects;C:\\Users\\DeepThought2\\Documents\\WinSCP\\WINDOWS\\Modules\\A.I Programming\\IntelliJ Projects\\out\\production\\IntelliJ Projects;C:\\Users\\DeepThought2\\Documents\\WinSCP\\WINDOWS\\Modules\\A.I Programming\\IntelliJ Projects\\lib\\clojure-1.8.0.jar;C:\\Users\\DeepThought2\\.IdeaIC2016.3\\config\\plugins\\clojure-plugin\\lib\\tools.nrepl-0.2.12.jar;C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2016.3.4\\lib\\idea_rt.jar\&quot; com.intellij.rt.execution.application.AppMain clojure.main -i C:\\Users\\DeepThought2\\AppData\\Local\\Temp\\form-init8757265028364286805.clj\nConnecting to local nREPL server...\nClojure 1.8.0\nnREPL server started on port 49301 on host 127.0.0.1\nfchcfh\nCompilerException java.lang.RuntimeException: Unable to resolve symbol: fchcfh in this context, compiling:(C:\\Users\\DeepThought2\\AppData\\Local\\Temp\\form-init8757265028364286805.clj:1:403)\n(+ 1 1)\n=&gt; 2\nLoading src/nested_average.clj... done\n(method-tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 18\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 181\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException clojure.core$_SLASH_ cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:128)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 181\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 185\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:82)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:82)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:82)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 195\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 195\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 195\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj...\nCompilerException java.lang.RuntimeException: Unmatched delimiter: ), compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:83:9)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:81)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj...\nCompilerException java.lang.UnsupportedOperationException: Can only recur from tail position, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:81:9)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 195\nLoading src/nested_average.clj... done\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:82)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; false\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:158)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 1009824507/1000000000\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 180\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/tree-average (nested_average.clj:83)\nLoading src/nested_average.clj...\nCompilerException java.lang.IllegalArgumentException: cond requires an even number of forms, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:75:4)\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 5931/512\nLoading src/nested_average.clj... done\n(tree-average '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 5931/512\nLoading src/nested_average.clj... done\nLoading src/nested_average.clj...\nCompilerException java.lang.RuntimeException: Unable to resolve symbol: lis in this context, compiling:(C:/Users/DeepThought2/Documents/WinSCP/WINDOWS/Modules/A.I Programming/IntelliJ Projects/src/nested_average.clj:54:11)\nLoading src/nested_average.clj... done\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 4\nLoading src/nested_average.clj... done\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  user/length-tree (nested_average.clj:56)\nLoading src/nested_average.clj... done\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\n=&gt; 4\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\n=&gt; 4\nLoading src/nested_average.clj... done\n(require '[clojure.tools.trace :refer :all])\n=&gt; nil\n(trace-vars sum-tree '(10 ((30 1) 20) (8 (5 ()) 9) 40))\nClassCastException clojure.lang.PersistentList cannot be cast to clojure.lang.Symbol  clojure.core/ns-resolve (core.clj:4239)\n(trace-vars sum-tree)\n=&gt; nil\n(sum-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nTRACE t2537: (user/sum-tree (10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nTRACE t2538: | (user/sum-tree 10)\nTRACE t2538: | =&gt; 10\nTRACE t2539: | (user/sum-tree (((30 1) 20) (8 (5 (50 7)) 9) 40))\nTRACE t2540: | | (user/sum-tree ((30 1) 20))\nTRACE t2541: | | | (user/sum-tree (30 1))\nTRACE t2542: | | | | (user/sum-tree 30)\nTRACE t2542: | | | | =&gt; 30\nTRACE t2543: | | | | (user/sum-tree (1))\nTRACE t2544: | | | | | (user/sum-tree 1)\nTRACE t2544: | | | | | =&gt; 1\nTRACE t2545: | | | | | (user/sum-tree ())\nTRACE t2545: | | | | | =&gt; 0\nTRACE t2543: | | | | =&gt; 1\nTRACE t2541: | | | =&gt; 31\nTRACE t2546: | | | (user/sum-tree (20))\nTRACE t2547: | | | | (user/sum-tree 20)\nTRACE t2547: | | | | =&gt; 20\nTRACE t2548: | | | | (user/sum-tree ())\nTRACE t2548: | | | | =&gt; 0\nTRACE t2546: | | | =&gt; 20\nTRACE t2540: | | =&gt; 51\nTRACE t2549: | | (user/sum-tree ((8 (5 (50 7)) 9) 40))\nTRACE t2550: | | | (user/sum-tree (8 (5 (50 7)) 9))\nTRACE t2551: | | | | (user/sum-tree 8)\nTRACE t2551: | | | | =&gt; 8\nTRACE t2552: | | | | (user/sum-tree ((5 (50 7)) 9))\nTRACE t2553: | | | | | (user/sum-tree (5 (50 7)))\nTRACE t2554: | | | | | | (user/sum-tree 5)\nTRACE t2554: | | | | | | =&gt; 5\nTRACE t2555: | | | | | | (user/sum-tree ((50 7)))\nTRACE t2556: | | | | | | | (user/sum-tree (50 7))\nTRACE t2557: | | | | | | | | (user/sum-tree 50)\nTRACE t2557: | | | | | | | | =&gt; 50\nTRACE t2558: | | | | | | | | (user/sum-tree (7))\nTRACE t2559: | | | | | | | | | (user/sum-tree 7)\nTRACE t2559: | | | | | | | | | =&gt; 7\nTRACE t2560: | | | | | | | | | (user/sum-tree ())\nTRACE t2560: | | | | | | | | | =&gt; 0\nTRACE t2558: | | | | | | | | =&gt; 7\nTRACE t2556: | | | | | | | =&gt; 57\nTRACE t2561: | | | | | | | (user/sum-tree ())\nTRACE t2561: | | | | | | | =&gt; 0\nTRACE t2555: | | | | | | =&gt; 57\nTRACE t2553: | | | | | =&gt; 62\nTRACE t2562: | | | | | (user/sum-tree (9))\nTRACE t2563: | | | | | | (user/sum-tree 9)\nTRACE t2563: | | | | | | =&gt; 9\nTRACE t2564: | | | | | | (user/sum-tree ())\nTRACE t2564: | | | | | | =&gt; 0\nTRACE t2562: | | | | | =&gt; 9\nTRACE t2552: | | | | =&gt; 71\nTRACE t2550: | | | =&gt; 79\nTRACE t2565: | | | (user/sum-tree (40))\nTRACE t2566: | | | | (user/sum-tree 40)\nTRACE t2566: | | | | =&gt; 40\nTRACE t2567: | | | | (user/sum-tree ())\nTRACE t2567: | | | | =&gt; 0\nTRACE t2565: | | | =&gt; 40\nTRACE t2549: | | =&gt; 119\nTRACE t2539: | =&gt; 170\nTRACE t2537: =&gt; 180\n=&gt; 180\n(trace-vars length-tree)\n=&gt; #'user/length-tree\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2602: (user/length-tree (10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2603: | (user/length-tree (((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2604: | | (user/length-tree ((8 (5 (50 7)) 9) 0))\nTRACE t2605: | | | (user/length-tree (0))\nTRACE t2606: | | | | (user/length-tree ())\nTRACE t2606: | | | | =&gt; 0\nTRACE t2605: | | | =&gt; 1\nTRACE t2604: | | =&gt; 2\nTRACE t2603: | =&gt; 3\nTRACE t2602: =&gt; 4\n=&gt; 4\nLoading src/nested_average.clj... done\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\n=&gt; 4\n(trace-vars length-tree)\n=&gt; #'user/length-tree\n(length-tree '(10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2934: (user/length-tree (10 ((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2935: | (user/length-tree (((30 1) 20) (8 (5 (50 7)) 9) 0))\nTRACE t2936: | | (user/length-tree ((8 (5 (50 7)) 9) 0))\nTRACE t2937: | | | (user/length-tree (0))\nTRACE t2938: | | | | (user/length-tree ())\nTRACE t2938: | | | | =&gt; 0\nTRACE t2937: | | | =&gt; 1\nTRACE t2936: | | =&gt; 2\nTRACE t2935: | =&gt; 3\nTRACE t2934: =&gt; 4\n=&gt; 4\nLoading src/nested_average.clj... done\n(compute-across [count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0])\nArityException Wrong number of args (1) passed to: user/compute-across  clojure.lang.AFn.throwArity (AFn.java:429)\n(compute-across [inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0])\nArityException Wrong number of args (1) passed to: user/compute-across  clojure.lang.AFn.throwArity (AFn.java:429)\n(compute-across [inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40)\n                 ])\nArityException Wrong number of args (1) passed to: user/compute-across  clojure.lang.AFn.throwArity (AFn.java:429)\nLoading src/nested_average.clj... done\n(compute-across [inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0])\nArityException Wrong number of args (1) passed to: user/compute-across  clojure.lang.AFn.throwArity (AFn.java:429)\n(tail-count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0)\nArityException Wrong number of args (2) passed to: user/tail-count  clojure.lang.AFn.throwArity (AFn.java:429)\n(tail-count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0)\nArityException Wrong number of args (2) passed to: user/tail-count  clojure.lang.AFn.throwArity (AFn.java:429)\n(tail-count '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40))\nArityException Wrong number of args (1) passed to: user/tail-count  clojure.lang.AFn.throwArity (AFn.java:429)\n(tail-count inc '(10 ((30 1) 20) (8 (5 (50 7)) 9) 40) 0)\nIllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:542)\n(tail-count inc '(1) 0)\nIllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:542)\n\nProcess finished with exit code 1\n&quot; &quot;(tail-count [1 [']])&quot; &quot;(tail-count [1 '(1 9) 0])&quot; &quot;(tail-count [inc '(1 9) 0])&quot; &quot;(tail-count [1 ['(1 9)] 0])&quot; &quot;(tail-count 1 ['(1 9)] 0)&quot; &quot;(tail-count inc ['(1 9)] 0)&quot; &quot;(tail-count inc[1] ['(1 9)] 0)&quot; &quot;(tail-count 1 '(1 9) 0)&quot; &quot;(tail-count inc[1] '(1 9) 0)&quot; &quot;(tail-count [1] '(1 9) [0])&quot; &quot;(tail-count [inc [1] 0])&quot; &quot;(tail-count [1] '(1 9) 0)&quot; &quot;(tail-count [1] '(1 (10)9) 0)&quot; &quot;(tail-count [1 '(1 (10)9) 0])&quot; &quot;(tail-count (inc [1]) '(1 9) 0)&quot; &quot;(tail-count (inc 1) '(1 9) 0)&quot; &quot;(tail-count ((inc [1]) '(1 9) 0))&quot; &quot;(tail-count (([1]) '(1 9) 0))&quot; &quot;(tail-count ((1) '(1 9) 0))&quot; &quot;(tail-count ((inc) '(1 9) 0))&quot; &quot;(tail-count (inc '(1 9) 0))&quot; &quot;(sum-up-with-recur (range 10) 0)\n45&quot; &quot;(tail-count(range 10) 0)&quot; &quot;(tail-count('(1(9))) 0)&quot; &quot;(tail-count(list? '(1 9) 0))&quot; &quot;(tail-count('(1 9) 0))&quot; &quot;(tail-count(list '(1 9) 0))&quot; &quot;(tail-count list? '(1 9) 0)&quot; &quot;(tail-count '(1 9) 0)&quot; &quot;(tail-count '(1 9(10)) 0)&quot; &quot;(tail-count '(1 9 10) 0)&quot; &quot;(tail-count '(1 9 (10)) 0)&quot; &quot;(sum-tree '(1 9 10))&quot; &quot;(sum-tree '(1 9(10(10)) 10))#&quot; &quot;(sum-tree '(1 9(10(10)) 10))&quot; &quot;(tail-sum '(1) 0)&quot; &quot;(tail-sum '(1 2) 0)&quot; &quot;(tail-sum '(1 2) 1)&quot; &quot;(tail-sum '(1 2) 99)&quot; &quot;(tail-sum 0 '(1 2))&quot; &quot;(tail-sum 0 '(1 9))&quot; &quot;(tail-sum '(1 9))&quot; &quot;(sum [39 5 1] 0)&quot; &quot;(sum '(39 (5) 1) 0)&quot; &quot;(sum '(39 5 1) 0)&quot; &quot;(sum '(39 5 1)1)&quot; &quot;(sum '(39 5 1))&quot; &quot;(sum '(39 (5) 1))&quot; &quot;(sum '(39 (5) 1)0)&quot;], :remote []}}</component>
</project>